---
AWSTemplateFormatVersion: '2010-09-09'
Description: >
  This cloudformation template enables SageMaker Studio to launch and connect to EMR clusters.
  The EMR cluster is launched via Service Catalog.
  This template creates a demonstration SageMaker Studio Domain & SageMaker User Profile. It ppopulates Service Catalog 
  with a Product that consists of another cloudformation template for launching EMR.
  It creates the Studio Domain in a private VPC and establishes connectivity with EMR via No-Auth as described in
     "https://aws.amazon.com/blogs/machine-learning/part-1-create-and-manage-amazon-emr-clusters-from-sagemaker-studio-to-run-interactive-spark-and-ml-workloads/"

Mappings:
  VpcConfigurations:
    cidr:
      Vpc: 10.0.0.0/16
      PublicSubnet1: 10.0.10.0/24
      PrivateSubnet1: 10.0.20.0/24
  ClusterConfigurations:
    emr:
      BootStrapScriptFile: https://raw.githubusercontent.com/pranavvm26/sagemaker-studio-emr/main/cloudformation/getting_started/emr_bootstrapping/installpylibs-py39.sh
      StepScriptFile: https://raw.githubusercontent.com/pranavvm26/sagemaker-studio-emr/main/cloudformation/getting_started/emr_bootstrapping/configurekdc.sh

Parameters:
  SageMakerStudioDomainName:
    Type: String
    Description: Name of the Studio Domain to Create
    Default: GenerativeAIDomain
  SageMakerStudioDefaultUserName:
    Type: String
    Description: Name of gen ai user to create in SageMaker Domain
    Default: genai-user    

Resources:
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join [ "-", [ "sagemaker-emr-template-cfn", !Select [ 2, !Split [ "/", !Ref AWS::StackId ] ] ] ]

  VPC:
    Type: 'AWS::EC2::VPC'
    Properties:
      CidrBlock: !FindInMap 
        - VpcConfigurations
        - cidr
        - Vpc
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: "for-use-with-amazon-emr-managed-policies"
          Value: "true"
        - Key: Name
          Value: !Sub '${AWS::StackName}-VPC'
 
  InternetGateway:
    Type: 'AWS::EC2::InternetGateway'
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-IGW'
 
  InternetGatewayAttachment:
    Type: 'AWS::EC2::VPCGatewayAttachment'
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC
 
  PublicSubnet1:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select 
        - 0
        - !GetAZs ''
      CidrBlock: !FindInMap 
        - VpcConfigurations
        - cidr
        - PublicSubnet1
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName} Public Subnet (AZ1)'
 
  PrivateSubnet1:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select 
        - 0
        - !GetAZs ''
      CidrBlock: !FindInMap 
        - VpcConfigurations
        - cidr
        - PrivateSubnet1
      MapPublicIpOnLaunch: false
      Tags:
        - Key: "for-use-with-amazon-emr-managed-policies"
          Value: "true"
        - Key: Name
          Value: !Sub '${AWS::StackName} Private Subnet (AZ1)'
 
  NatGateway1EIP:
    Type: 'AWS::EC2::EIP'
    DependsOn: InternetGatewayAttachment
    Properties:
      Domain: vpc
 
  NatGateway1:
    Type: 'AWS::EC2::NatGateway'
    Properties:
      AllocationId: !GetAtt 
        - NatGateway1EIP
        - AllocationId
      SubnetId: !Ref PublicSubnet1
 
  PublicRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName} Public Routes'
 
  DefaultPublicRoute:
    Type: 'AWS::EC2::Route'
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
 
  PublicSubnet1RouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1
 
  PrivateRouteTable1:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName} Private Routes (AZ1)'


  PrivateSubnet1RouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      SubnetId: !Ref PrivateSubnet1
 
  PrivateSubnet1InternetRoute:
    Type: 'AWS::EC2::Route'
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway1
  
  S3Endpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      VpcEndpointType: Gateway
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action:
              - '*'
            Resource:
              - '*'
      VpcId: !Ref VPC
      RouteTableIds:
        - !Ref PrivateRouteTable1
 
  SageMakerInstanceSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      Tags:
        - Key: "for-use-with-amazon-emr-managed-policies"
          Value: "true"
      GroupName: SMSG
      GroupDescription: Security group with no ingress rule
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
      VpcId: !Ref VPC
  SageMakerInstanceSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: '-1'
      GroupId: !Ref SageMakerInstanceSecurityGroup
      SourceSecurityGroupId: !Ref SageMakerInstanceSecurityGroup
  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow TLS for VPC Endpoint
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-endpoint-security-group
  EndpointSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: '-1'
      GroupId: !Ref VPCEndpointSecurityGroup
      SourceSecurityGroupId: !Ref SageMakerInstanceSecurityGroup

  SageMakerExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: !Sub "${AWS::StackName}-OSE-EMR-SageMakerExecutionRole"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - sagemaker.amazonaws.com
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-sageemr'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: ReadFromOpenSearch
                Effect: Allow
                Action:
                  - "es:ESHttp*"
                Resource:
                  - !Sub arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/*
              - Sid: ReadSecretFromSecretsManager
                Effect: Allow
                Action:
                  - "secretsmanager:GetSecretValue"
                Resource: !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:*"
              - Effect: Allow
                Action:
                  - elasticmapreduce:ListInstances
                  - elasticmapreduce:DescribeCluster
                  - elasticmapreduce:DescribeSecurityConfiguration
                  - elasticmapreduce:CreatePersistentAppUI
                  - elasticmapreduce:DescribePersistentAppUI
                  - elasticmapreduce:GetPersistentAppUIPresignedURL
                  - elasticmapreduce:GetOnClusterAppUIPresignedURL
                  - elasticmapreduce:ListClusters
                  - iam:GetRole
                Resource: '*'
              - Effect: Allow
                Action:
                  - elasticmapreduce:DescribeCluster
                  - elasticmapreduce:ListInstanceGroups
                Resource: !Sub "arn:${AWS::Partition}:elasticmapreduce:*:*:cluster/*"
              - Effect: Allow
                Action:
                  - elasticmapreduce:ListClusters
                Resource: '*'
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSageMakerFullAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AWSLambda_FullAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/SecretsManagerReadWrite"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonOpenSearchIngestionFullAccess"

  VPCEndpointSagemakerAPI:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sagemaker.api'
      VpcId: !Ref VPC
  VPCEndpointSageMakerRuntime:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sagemaker.runtime'
      VpcId: !Ref VPC
  VPCEndpointSTS:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sts'
      VpcId: !Ref VPC
  VPCEndpointCW:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.monitoring'
      VpcId: !Ref VPC
  
  VPCEndpointCWL:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs'
      VpcId: !Ref VPC
  
  VPCEndpointECR:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.dkr'
      VpcId: !Ref VPC
  
  VPCEndpointECRAPI:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: '*'
            Resource: '*'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.api'
      VpcId: !Ref VPC
  
  # SageMaker Studio Domain and User Profile Setup
  ###################################################

  StudioDomain:
    Type: AWS::SageMaker::Domain
    Properties:
      DomainName: !Ref SageMakerStudioDomainName
      AppNetworkAccessType: VpcOnly
      AuthMode: IAM
      VpcId: !Ref VPC
      SubnetIds: 
        - !Ref PrivateSubnet1
      DefaultUserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn
        SecurityGroups:
           - !Ref SageMakerInstanceSecurityGroup
 
  StudioUserProfile:
    Type: AWS::SageMaker::UserProfile
    Properties:
      DomainId: !Ref StudioDomain
      UserProfileName: !Ref SageMakerStudioDefaultUserName
      UserSettings: 
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn
  
  # Automatically Create SageMaker Apps
  ###################################################  

  SageMakerCreateSystemAppLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: createSageMakerSystemApp
      Handler: index.lambda_handler
      Role: !GetAtt SageMakerExecutionRole.Arn
      Runtime: python3.10
      Environment:
        Variables:
          DOMAIN_ID: !Ref StudioDomain
          REGION: !Ref 'AWS::Region'
          USER_PROFILE_NAME: !Ref SageMakerStudioDefaultUserName
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import cfnresponse
          import logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)


          domain_id = os.environ.get('DOMAIN_ID')

          user_profile_name = os.environ.get('USER_PROFILE_NAME')

          region_name = os.environ.get('REGION')

          sagemaker_client = boto3.client('sagemaker', region_name=region_name)

          logger.info(f"DomainID: {domain_id}, User Profile: {user_profile_name}, Region Name: {region_name}")

          def sendResponseCfn(event, context, responseStatus):
              responseData = {}
              responseData['Data'] = {}
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")

          def lambda_handler(event, context):

              logger.info("event: {}".format(event))
              app_type = 'JupyterServer'
              app_name = 'default'

              # Create the SageMaker app
              response = sagemaker_client.create_app(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  AppType=app_type,
                  AppName=app_name,
                  ResourceSpec={
                      'InstanceType': 'system'
                  }
              )

              try:
                if "AppArn" not in response.keys():
                  raise Exception(f"SystemApp could not be created, exception: {response}")

                logger.info("App Created with ARN: {}".format(response["AppArn"]))

                sendResponseCfn(event, context, cfnresponse.SUCCESS)

                return {
                    'statusCode': 200,
                    'body': json.dumps(response),
                    'app_arn': response["AppArn"]
                }
              except Exception as e:
                sendResponseCfn(event, context, cfnresponse.FAILED)
                return {
                    'statusCode': 400,
                    'body': json.dumps(e)
                }

    
  SageMakerSystemAppCreationTrigger:
    Type: Custom::SageMakerSystemAppCreation
    Properties:
      ServiceToken: !GetAtt SageMakerCreateSystemAppLambdaFunction.Arn

  SageMakerCreateSparkAppLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: createSageMakerSparkApp
      Handler: index.lambda_handler
      Role: !GetAtt SageMakerExecutionRole.Arn
      Runtime: python3.10
      Environment:
        Variables:
          DOMAIN_ID: !Ref StudioDomain
          REGION: !Ref 'AWS::Region'
          USER_PROFILE_NAME: !Ref SageMakerStudioDefaultUserName
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import cfnresponse
          import logging
          logger = logging.getLogger()

          logger.setLevel(logging.INFO)

          domain_id = os.environ.get('DOMAIN_ID')

          user_profile_name = os.environ.get('USER_PROFILE_NAME')

          region_name = os.environ.get('REGION')

          sagemaker_client = boto3.client('sagemaker', region_name=region_name)

          logger.info(f"DomainID: {domain_id}, User Profile: {user_profile_name}, Region Name: {region_name}")

          def sendResponseCfn(event, context, responseStatus):
            responseData = {}
            responseData['Data'] = {}
            cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              app_type = 'KernelGateway'
              app_name = 'sparkanalytics2'

              response = sagemaker_client.create_app(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  AppType=app_type,
                  AppName=app_name,
                  ResourceSpec={
                      'InstanceType': 'ml.t3.medium',
                      'SageMakerImageArn': "arn:aws:sagemaker:us-west-2:236514542706:image/sagemaker-sparkanalytics-310-v1"
                  }
              )

              try:
                if "AppArn" not in response.keys():
                  raise Exception(f"KernelGateway SparkAnalytics 2.0 app could not be created, exception: {response}")

                logger.info("App Created with ARN: {}".format(response["AppArn"]))

                sendResponseCfn(event, context, cfnresponse.SUCCESS)

                return {
                    'statusCode': 200,
                    'body': json.dumps(response),
                    'app_arn': response["AppArn"]
                }

              except Exception as e:
              
                sendResponseCfn(event, context, cfnresponse.FAILED)
                return {
                    'statusCode': 400,
                    'body': json.dumps(e)
                }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response)
              }
  
  SageMakerSparkAppCreationTrigger:
    Type: Custom::SageMakerSystemAppCreation
    Properties:
      ServiceToken: !GetAtt SageMakerCreateSparkAppLambdaFunction.Arn
  
  SageMakerCreateDistroAppLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: createSageMakerDistroApp
      Handler: index.lambda_handler
      Role: !GetAtt SageMakerExecutionRole.Arn
      Runtime: python3.10
      Environment:
        Variables:
          DOMAIN_ID: !Ref StudioDomain
          REGION: !Ref 'AWS::Region'
          USER_PROFILE_NAME: !Ref SageMakerStudioDefaultUserName
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import cfnresponse
          import logging
          logger = logging.getLogger()

          logger.setLevel(logging.INFO)

          domain_id = os.environ.get('DOMAIN_ID')

          user_profile_name = os.environ.get('USER_PROFILE_NAME')

          region_name = os.environ.get('REGION')

          sagemaker_client = boto3.client('sagemaker', region_name=region_name)

          logger.info(f"DomainID: {domain_id}, User Profile: {user_profile_name}, Region Name: {region_name}")

          def sendResponseCfn(event, context, responseStatus):
            responseData = {}
            responseData['Data'] = {}
            cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              app_type = 'KernelGateway'
              app_name = 'smds310'

              response = sagemaker_client.create_app(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  AppType=app_type,
                  AppName=app_name,
                  ResourceSpec={
                      'InstanceType': 'ml.t3.medium',
                      'SageMakerImageArn': "arn:aws:sagemaker:us-west-2:236514542706:image/sagemaker-base-python-310-v1"
                  }
              )

              try:
                if "AppArn" not in response.keys():
                  raise Exception(f"KernelGateway DataScience310 app could not be created, exception: {response}")

                logger.info("App Created with ARN: {}".format(response["AppArn"]))

                sendResponseCfn(event, context, cfnresponse.SUCCESS)

                return {
                    'statusCode': 200,
                    'body': json.dumps(response),
                    'app_arn': response["AppArn"]
                }

              except Exception as e:

                sendResponseCfn(event, context, cfnresponse.FAILED)
                return {
                    'statusCode': 400,
                    'body': json.dumps(e)
                }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response)
              }

  SageMakerDistroAppCreationTrigger:
    Type: Custom::SageMakerSystemAppCreation
    Properties:
      ServiceToken: !GetAtt SageMakerCreateDistroAppLambdaFunction.Arn
  
  # Llama 2 Text Gen Model Deloyment
  ###################################################  

  ChatModelLLMEndpoint:
    Type: "AWS::SageMaker::Endpoint"
    Properties:
      EndpointName: 'meta-llama2-7b-chat-tg-ep'
      EndpointConfigName: !GetAtt ChatModelLLMEndpointConfig.EndpointConfigName

  ChatModelLLMEndpointConfig:
    Type: "AWS::SageMaker::EndpointConfig"
    Properties:
      EndpointConfigName: 'meta-llama2-7b-chat-tg-epconfig'
      ProductionVariants:
        - InitialInstanceCount: 1
          InitialVariantWeight: 1.0
          InstanceType: "ml.g5.2xlarge"
          ModelName: !GetAtt ChatModelLLMModel.ModelName
          VariantName: 'variant1'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W1200
            reason: Solution does not have KMS encryption enabled by default

  ChatModelLLMModel:
    Type: "AWS::SageMaker::Model"
    Properties:
      ModelName: 'meta-llama2-7b-chat-tg-model'
      PrimaryContainer:
        ModelPackageName: 'arn:aws:sagemaker:us-west-2:594846645681:model-package/llama2-7b-f-v4-71eeccf76ddf33f2a18d2e16b9c7f302'
      ExecutionRoleArn: !GetAtt SageMakerExecutionRole.Arn
      EnableNetworkIsolation: true
  
  # Embedding Model Deployment
  ###################################################  

  EmbeddingModelEndpoint:
    Type: "AWS::SageMaker::Endpoint"
    Properties:
      EndpointName: "all-minilm-l6-v2-ep"
      EndpointConfigName: !GetAtt EmbeddingModelEndpointConfig.EndpointConfigName

  EmbeddingModelEndpointConfig:
    Type: "AWS::SageMaker::EndpointConfig"
    Properties:
      EndpointConfigName: "all-minilm-l6-v2-epconfig"
      ProductionVariants:
        - InitialInstanceCount: 1
          InitialVariantWeight: 1.0
          InstanceType: "ml.g5.2xlarge"
          ModelName: !GetAtt EmbeddingModel.ModelName
          VariantName: "variant1"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W1200
            reason: Solution does not have KMS encryption enabled by default

  EmbeddingModel:
    Type: "AWS::SageMaker::Model"
    Properties:
      ModelName: "all-minilm-l6-v2-model"
      PrimaryContainer:
        ModelDataUrl: !Sub "s3://jumpstart-cache-prod-${AWS::Region}/huggingface-infer/prepack/v1.0.0/infer-prepack-huggingface-textembedding-all-MiniLM-L6-v2.tar.gz"
        Image: !Sub "763104351884.dkr.ecr.${AWS::Region}.amazonaws.com/huggingface-pytorch-inference:1.10.2-transformers4.17.0-gpu-py38-cu113-ubuntu20.04"
        Environment: {"ENDPOINT_SERVER_TIMEOUT": "3600", "MODEL_CACHE_ROOT": "/opt/ml/model", "SAGEMAKER_PROGRAM": "inference.py", "SAGEMAKER_MODEL_SERVER_WORKERS":"1"}
        Mode: "SingleModel"
      ExecutionRoleArn: !GetAtt SageMakerExecutionRole.Arn

  InvokeEmbeddingEndpointLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: invokeEmbeddingEndpoint
      Handler: index.lambda_handler
      Role: !GetAtt SageMakerExecutionRole.Arn
      Runtime: python3.10
      Timeout: 120
      MemorySize: 128
      Environment:
        Variables:
          REGION: !Ref 'AWS::Region'
      Code:
        ZipFile: |
          import os
          import json
          import boto3

          region_name = os.environ.get('REGION')

          client = boto3.client("runtime.sagemaker", region_name=region_name)

          def invoke_embedding_endpoint(text):
              data = {
                  "text_inputs": [text]
              }
              body = json.dumps(data)
              response = client.invoke_endpoint(
                      EndpointName="all-minilm-l6-v2-ep",
                      Body=body,
                      ContentType="application/json"
              )
              result = json.loads(response['Body'].read().decode("utf-8"))["embedding"][0]
              return result

          def lambda_handler(event, context):
              resp = invoke_embedding_endpoint(text=event['input'])
              return {
                  'statusCode': 200,
                  'body': json.dumps(resp),
                  'sample_length': len(resp)
              }
      Environment:
        Variables:
          REGION: !Ref 'AWS::Region'
  
  # OpenSearch Setup with secrets
  ###################################################  

  OpenSearchSecret:
    Type: "AWS::SecretsManager::Secret"
    Properties:
      Description: OpenSearch username and password
      Name: !Sub OpenSearchSecret-${AWS::StackName}
      GenerateSecretString:
        SecretStringTemplate: '{"username": "raguser"}'
        GenerateStringKey: "password"
        PasswordLength: 32
        ExcludeCharacters: '"@/\'

  OpenSearchServiceDomain:
    Type: AWS::OpenSearchService::Domain
    Properties:
      AccessPolicies:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: '*'
            Action: 'es:*'
            Resource: !Sub arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/*/*
      EngineVersion: 'OpenSearch_2.9'
      ClusterConfig:
        InstanceType: "r6g.xlarge.search"
      EBSOptions:
        EBSEnabled: True
        VolumeSize: 20
        VolumeType: 'gp3'
      AdvancedSecurityOptions:
        AnonymousAuthEnabled: False
        Enabled: True
        InternalUserDatabaseEnabled: True
        MasterUserOptions:
          MasterUserName: !Sub '{{resolve:secretsmanager:${OpenSearchSecret}:SecretString:username}}'
          MasterUserPassword: !Sub '{{resolve:secretsmanager:${OpenSearchSecret}:SecretString:password}}'
      NodeToNodeEncryptionOptions:
        Enabled: True
      EncryptionAtRestOptions:
        Enabled: True
        KmsKeyId: alias/aws/es
      DomainEndpointOptions:
        EnforceHTTPS: True
  
  # Products populated to Service Catalog
  ###################################################  
  
  SageMakerStudioEMRNoAuthProduct:
    Type: AWS::ServiceCatalog::CloudFormationProduct
    Properties:
      Owner: AWS
      Name: SageMaker Studio Domain No Auth EMR
      ProvisioningArtifactParameters:
        - Name: SageMaker Studio Domain No Auth EMR
          Description: Provisions a SageMaker domain and No Auth EMR Cluster
          Info:
            LoadTemplateFromURL: https://raw.githubusercontent.com/pranavvm26/sagemaker-studio-emr/main/cloudformation/getting_started/CFN-EMR-NoStudioNoAuthTemplate-v4.yaml
      Tags:
        - Key: "sagemaker:studio-visibility:emr"
          Value: "true"
 
  SageMakerStudioEMRNoAuthProductPortfolio:
    Type: AWS::ServiceCatalog::Portfolio
    Properties:
      ProviderName: AWS
      DisplayName: SageMaker Product Portfolio
 
  SageMakerStudioEMRNoAuthProductPortfolioAssociation:
    Type: AWS::ServiceCatalog::PortfolioProductAssociation
    Properties:
      PortfolioId: !Ref SageMakerStudioEMRNoAuthProductPortfolio
      ProductId: !Ref SageMakerStudioEMRNoAuthProduct
  
  EMRNoAuthLaunchConstraint:
    Type: 'AWS::IAM::Role'
    Properties:
      Policies:
        - PolicyDocument:
            Statement:
            - Action:
              - s3:*
              Effect: Allow
              Resource:
              - !Sub "arn:${AWS::Partition}:s3:::sagemaker-emr-template-cfn-*/*"
              - !Sub "arn:${AWS::Partition}:s3:::sagemaker-emr-template-cfn-*"
            - Action:
              - s3:GetObject
              Effect: Allow
              Resource: "*"
              Condition:
                StringEquals:
                  s3:ExistingObjectTag/servicecatalog:provisioning: 'true'
          PolicyName: !Sub ${AWS::StackName}-${AWS::Region}-S3-Policy
        - PolicyDocument:
            Statement:
              - Action:
                  - "sns:Publish"
                Effect: Allow
                Resource: !Sub "arn:${AWS::Partition}:sns:${AWS::Region}:${AWS::AccountId}:*"
            Version: "2012-10-17"
          PolicyName: SNSPublishPermissions
        - PolicyDocument:
            Statement:
              - Action:
                  - "ec2:CreateSecurityGroup"
                  - "ec2:RevokeSecurityGroupEgress"
                  - "ec2:DeleteSecurityGroup"
                  - "ec2:createTags"
                  - "iam:TagRole"
                  - "ec2:AuthorizeSecurityGroupEgress"
                  - "ec2:AuthorizeSecurityGroupIngress"
                  - "ec2:RevokeSecurityGroupIngress"
                Effect: Allow
                Resource: "*"
            Version: "2012-10-17"
          PolicyName: EC2Permissions
        - PolicyDocument:
            Statement:
              - Action:
                  - "elasticmapreduce:RunJobFlow"
                Effect: Allow
                Resource: !Sub "arn:${AWS::Partition}:elasticmapreduce:${AWS::Region}:${AWS::AccountId}:cluster/*"
            Version: "2012-10-17"
          PolicyName: EMRRunJobFlowPermissions
        - PolicyDocument:
            Statement:
              - Action:
                  - "iam:PassRole"
                Effect: Allow
                Resource:
                  - !GetAtt EMRClusterinstanceProfileRole.Arn
                  - !GetAtt EMRClusterServiceRole.Arn
              - Action:
                  - "iam:CreateInstanceProfile"
                  - "iam:RemoveRoleFromInstanceProfile"
                  - "iam:DeleteInstanceProfile"
                  - "iam:AddRoleToInstanceProfile"
                Effect: Allow
                Resource: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/SC-*"
            Version: "2012-10-17"
          PolicyName: IAMPermissions
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - 
            Effect: "Allow"
            Principal:
              Service: 
                - "servicecatalog.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSServiceCatalogAdminFullAccess"
        - "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonEMRFullAccessPolicy_v2"
        - "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSLambda_FullAccess"
        - "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonOpenSearchIngestionFullAccess"
         
# Sets the principal who can initate provisioning from Service Studio
#######################################################################
  
  SageMakerStudioEMRNoAuthProductPortfolioPrincipalAssociation:
    Type: AWS::ServiceCatalog::PortfolioPrincipalAssociation
    Properties:
      PrincipalARN: !GetAtt SageMakerExecutionRole.Arn
      PortfolioId: !Ref SageMakerStudioEMRNoAuthProductPortfolio
      PrincipalType: IAM
 
  SageMakerStudioPortfolioLaunchRoleConstraint:
    Type: AWS::ServiceCatalog::LaunchRoleConstraint
    Properties:
      PortfolioId: !Ref SageMakerStudioEMRNoAuthProductPortfolio
      ProductId: !Ref SageMakerStudioEMRNoAuthProduct
      RoleArn: !GetAtt EMRNoAuthLaunchConstraint.Arn
      Description: Role used for provisioning

# EMR IAM Roles
########################################################################
  EMRClusterServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - elasticmapreduce.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEMRServicePolicy_v2
      Path: "/"
      Policies:
        - PolicyName:
            Fn::Sub: AllowEMRInstnaceProfilePolicy-${AWS::StackName}
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: "iam:PassRole"
                Resource: !GetAtt EMRClusterinstanceProfileRole.Arn

  # User's Should Consider using RoleBasedAccess Control now that it is available to pass your SageMaker execution role
  # to the cluster instead.
  EMRClusterinstanceProfileRole:
    Properties:
      RoleName:
        Fn::Sub: "${AWS::StackName}-EMRClusterinstanceProfileRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
                - lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSageMakerFullAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonOpenSearchIngestionFullAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AWSLambda_FullAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/SecretsManagerReadWrite"
      Path: "/"
    Type: AWS::IAM::Role

# Manage EMR Log and Artifacts S3 Bucket
########################################################################
  CopyZips:
    Type: Custom::CopyZips
    DependsOn: CleanUpBucketonDelete
    Properties:
      ServiceToken:
        Fn::GetAtt: CopyZipsFunction.Arn
      DestBucket:
        Ref: S3Bucket
      GitHubURLs:
        - Fn::FindInMap:
            - ClusterConfigurations
            - emr
            - BootStrapScriptFile
        - Fn::FindInMap:
            - ClusterConfigurations
            - emr
            - StepScriptFile

  BucketManagementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: "/"
      Policies:
        - PolicyName:
            Fn::Sub: BucketManagementLambdaPolicy-${AWS::StackName}
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: "*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - Fn::Sub: arn:aws:s3:::${S3Bucket}/*
  CopyZipsFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Downloads files from GitHub and uploads them to an S3 bucket
      Handler: index.handler
      Runtime: python3.8
      Role:
        Fn::GetAtt: BucketManagementRole.Arn
      Timeout: 900
      Code:
        ZipFile: |
          import json
          import logging
          import threading
          import boto3
          import urllib.request
          import cfnresponse
          
          def download_from_github_and_upload_to_s3(github_url, dest_bucket, dest_key):
              with urllib.request.urlopen(github_url) as response:
                  file_content = response.read()

              s3 = boto3.client('s3')
              s3.put_object(Bucket=dest_bucket, Key=dest_key, Body=file_content)

          def timeout(event, context):
              logging.error('Execution is about to time out, sending failure response to CloudFormation')
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, None)
          
          def handler(event, context):
              # make sure we send a failure to CloudFormation if the function
              # is going to timeout
              timer = threading.Timer((context.get_remaining_time_in_millis()
                        / 1000.00) - 0.5, timeout, args=[event, context])
              timer.start()
              print('Received event: %s' % json.dumps(event))
              status = cfnresponse.SUCCESS
              try:
                  github_urls = event['ResourceProperties']['GitHubURLs']
                  dest_bucket = event['ResourceProperties']['DestBucket']

                  if event['RequestType'] == 'Delete':
                      
                      s3 = boto3.client('s3')
                      for github_url in github_urls:
                          s3_key = f'artifacts/emr/{github_url.split("/")[-1]}'
                          s3.delete_object(Bucket=dest_bucket, Key=s3_key)

                  else:
                      for github_url in github_urls:
                          dest_key = f'artifacts/emr/{github_url.split("/")[-1]}'
                          download_from_github_and_upload_to_s3(github_url, dest_bucket, dest_key)
                      # copy_objects(source_bucket, dest_bucket, prefix, objects)
              except Exception as e:
                  logging.error('Exception: %s' % e, exc_info=True)
                  status = cfnresponse.FAILED
              finally:
                  timer.cancel()
                  cfnresponse.send(event, context, status, {}, None)
  CleanUpBucketonDelete:
    Type: Custom::emptybucket
    Properties:
      ServiceToken:
        Fn::GetAtt:
          - CleanUpBucketonDeleteLambda
          - Arn
      BucketName:
        Ref: S3Bucket
  CleanUpBucketonDeleteLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile:
          !Sub |
          import json, boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  logger.info("bucket: {}, event['RequestType']: {}".format(bucket,event['RequestType']))
                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          logger.info("delete obj: {}".format(obj))
                          s3.Object(bucket.name, obj.key).delete()
          
                  sendResponseCfn(event, context, cfnresponse.SUCCESS)
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  sendResponseCfn(event, context, cfnresponse.FAILED)
          
          def sendResponseCfn(event, context, responseStatus):
              responseData = {}
              responseData['Data'] = {}
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")
      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt BucketManagementRole.Arn

# Stack Outputs
###########################################################################
Outputs:
  SageMakerEMRDemoCloudformationVPCId:
    Description: The ID of the Sagemaker Studio VPC
    Value: !Ref VPC
    Export:
      Name: "SageMakerEMRDemoCloudformationVPCId"

  SageMakerEMRDemoCloudformationSubnetId:
    Description: The Subnet Id of Sagemaker Studio
    Value: !Ref PrivateSubnet1
    Export:
      Name: "SageMakerEMRDemoCloudformationSubnetId"

  SageMakerEMRDemoCloudformationSecurityGroup:
    Description: The Security group of Sagemaker Studio instance
    Value: !Ref SageMakerInstanceSecurityGroup
    Export:
      Name: "SageMakerEMRDemoCloudformationSecurityGroup"

  SageMakerEMRDemoCloudformationEMRClusterinstanceProfileRole:
    Description: Role for EMR Cluster's InstanceProfile
    Value: !Ref EMRClusterinstanceProfileRole
    Export:
      Name: "SageMakerEMRDemoCloudformationEMRClusterinstanceProfileRole"

  SageMakerEMRDemoCloudformationEMRClusterServiceRole:
    Description: Role for EMR Cluster's Service Role
    Value: !Ref EMRClusterServiceRole
    Export:
      Name: "SageMakerEMRDemoCloudformationEMRClusterServiceRole"

  SageMakerEMRDemoCloudformationS3BucketName:
    Description: Bucket Name for Amazon S3 bucket
    Value:
      Ref: S3Bucket
    Export:
      Name: "SageMakerEMRDemoCloudformationS3BucketName"